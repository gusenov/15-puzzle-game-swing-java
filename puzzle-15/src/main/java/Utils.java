import java.util.Random;

/** Вспомогательный класс с полезными методами. */
public class Utils {

    /**
     * Сгенерировать псевдослучайное целое число в диапазоне [min; max].
     *
     * @param min  минимально допустимое число.
     * @param max  максимально допустимое число.
     * @return     псевдослучайное целое число.
     */
    public static int randInt(int min, int max) {
        Random rand = new Random();
        int randomNum = rand.nextInt((max - min) + 1) + min;
        return randomNum;
    }

    /**
     * Преобразовать одномерный индекс в двумерный.
     *
     * Например, есть поле размером 4 x 4. Всего получается 16 ячеек.
     * У каждой ячейки есть свой порядковый номер: от 1 до 16. У первой ячейки индекс 1, а у последней 16.
     * Это получается одномерный индекс (1D).
     *
     * Но ячейки этого поля можно и по другому адресовать.
     * Каждая ячейка расположена на пересечении определенной строки и определенного столбца.
     * У первой ячейки координаты (1; 1), а у последней (4; 4).
     * Это получается двумерный индекс (2D).
     *
     * Можно составить формулы для конвертации одномерного индекса в двумерный и обратно.
     * Это нужно вот зачем. К примеру у нас есть какая-нибудь двумерная сущность: игровое поле с ячейками, таблица, матрица и т.д.
     * Мы можем записать эту сущность в одномерный массив или связный список, например, LinkedList в Java.
     * Но LinkedList не позволяет нам обращаться к элементам по двумерному индексу.
     * LinkedList предоставляет доступ к элементам только по одномерному индексу.
     * А нам к примеру нужно получить ячейку расположенную в третьей строке и четвертом столбце.
     * Поэтому для начала нужно преобразовать двумерный индекс в одномерный и уже по нему запрашивать элемент.
     *
     * Формулы для zero-based индексов (т.е. индексов начинающихся с нуля) такие:
     * idx2D = (idx1D / rows_cnt; idx1D % cols_cnt)
     * idx1D = idx2D_row * rows_cnt + idx2D_col
     *
     * Например, есть zero-based двумерный индекс (1; 2), фактически он соответствует ячейке во второй строке и третьем столбце.
     * idx2D_row = 1
     * rows_cnt = 4
     * idx2D_col = 2
     * idx1D = idx2D_row * rows_cnt + idx2D_col = 1 * 4 + 2 = 6
     * Т.е. это будет 6 элемент считая от нуля в нашем связном списке.
     *
     * И обратно:
     * idx1D = 6
     * rows_cnt = 4
     * cols_cnt = 4
     * idx2D = (idx1D / rows_cnt; idx1D % cols_cnt) = (6 / 4; 6 % 4) = (1; 2)
     *
     * Тут суть в том, что это нам позволяет работать с двумерной структурой через одномерный массив.
     * Но надо знать количество строк и количество столбцов в 2D структуре.
     *
     * @param index1D  одномерный индекс.
     * @param rows     количество строк.
     * @param cols     количество столбцов.
     * @return         двумерный индекс.
     */
    public static int[] convertIndex1DTo2D(int index1D, int rows, int cols) {
        return new int[] { index1D / rows, index1D % cols };
    }

    /**
     * Преобразовать двумерный индекс в одномерный.
     *
     * @param row   строка.
     * @param col   столбец.
     * @param rows  количество строк.
     * @return      одномерный индекс.
     */
    public static int convertIndex2DTo1D(int row, int col, int rows) {
        return row * rows + col;
    }

}
